# 一些高级概念
这些概念有助于了解复杂的代码库，或创建通用的 Rust API  
类型系统、字符串、迭代器、闭包、模块  

## 类型系统
Rust 主要是一种面向表达式的语言，大多数构造包含返回值。  
代码块表达式用 *{* 和 *}* 标记开始和结束，通常返回值。  
代码块会引入新的作用域，从 main 作用域开始，可以嵌套。  
查看代码0701了解作用域的概念。  

裸代码块可以执行多个命令并返回，接在 match 表达式后：  
* 可以直接匹配返回值并执行相应的操作或返回其他结果  
* 可以实现类似 C 的 switch 效果，且不需要 break  

if else 表达式可以直接返回值(同类型)用于初始化变量。  
即 if 和 else 需要返回同样数据类型的值用于变量赋值。  
相比 Python 语言必须先初始化变量再更新，Rust更简洁。  
对比0703的 Rust 和 Python 代码了解详情。  

let 语句不仅用于创建新的变量绑定，实际上也匹配模式。  
例如带 mut 表示绑定模式允许变量再次绑定到其他值上。  
再有 ref 或运算符 & 表示创建指向任何值的引用或指针。  
参考0704的代码了解关键字 ref 和 mut 的作用。  

let 可以从带有复合数据类型的字段中提取并赋值给变量。  
参考0705代码了解从一个结构化数据类型中解构数据片段。  
大部分时候因为 & 比 ref 简洁而成为首选，但也有例外：  
在 match 表达式中通过引用来匹配时，运算符 & 不可用  
参考0706代码了解 ref 的正确打开方式。  

解构语法在枚举和函数参数上也可用，参考0707和08代码。  
loop 循环也是一个带返回值的表达式，参考0710代码了解。  

运算中混合带符号和无符号的数字类型时，Rust不自动转换。  
CPP 自动转换数字类型可能会带来意外错误，参考0711代码。  
相对的，Rust 会要求显示转换以确保安全，参考0712代码。  
Rust 能推断数据类型并报告匹配错误，参考0713和0714。  

使用类型别名可以增加代码可读性，并移除多余的类型签名。  
如果类型包含范型参数或生命周期，别名类也同样需要包含。  
参考0715了解别名创建、范型参数和生命周期的范例。  

## 字符串
因为Rust对堆和堆栈上的分配值区别对待，字符串变得复杂。  
String是包含所有权的字符串，&str是指针类的借用字符串。  
String类型来自标准库，通过堆分配UTF-8编码的字节序列。  

有多种方式创建String，注意clone()方法开销比较昂贵。  
String在标准库中也有很多便捷方法，参考代码0716了解。  

借用字符串&str也叫做字符串切片的引用，是str类型的引用。  
str类型不属于标准库，是编译器可识别的内置类型，&表指针。  
str是有限但大小未知，即不定长的UTF-8编码的连续字节序列。  
let定义变量需要在堆栈上分配固定大小，因此无法初始化str。  
字符串变量默认是&'static str类型，'static表生命周期。  
该生命周期修饰符表示字符串在程序存续期间保持不变，即静态。  

注意在获取字符串片段时需要对字符串切片操作，否则会报错。  
索引操作不可越界，使用迭代器更为安全，参考0717  
除了拼接字符串是需要转换为String类型，其他用&str保险：  
当字符串已经分配，引用可以节省复制和再分配的成本。  
传递&str的成本几乎为零，没有分配的成本，也不会复制内存。  

