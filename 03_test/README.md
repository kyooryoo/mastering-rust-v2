### 测试的意义
虽然并不能验证代码中的BUG，但有助于部署代码到生产环境，并使代码在长期维护中保持健壮。  
在代码的规模重构中也很有帮助，并防止代码库的回归，即解决升级后原有功能可能发成的异常。  
有助于代码模块化，即构造无状态函数，避免依赖全局可变状态，因为很难为后者编写测试。  
编写测试代码的过程本身也有助于发现代码错误，对代码库之间关系也有类似文档的帮助作用。  

单元测试是单个组件的轻量级测试，作为子模块与被测试代码一起存在同一模块中，带注释属性。  
集成测试会模拟真实的测试场景，在程序库根目录下单独编写，更像是被测试程序的使用者。  

### 注释和断言
注释有`#[<name>]`和`#![<name>]`两种类型，前者对子模块生效，后者对整个模块生效。  
相应的，前者放在对应子模块的上方，后者放在整个模块的首行。  

断言用来判断程序组件的预期行为，如下断言函数是常用的几种：  
* assert!(exp, msg) 判断*exp*是否为真，否则提供*msg*的错误信息  
* assert_eq!(a,b,msg) 判断*a*和*b*是否相等，否则提供*msg*的错误信息  
* assert_ne!(a,b,msg) 判断*a*和*b*是否不等，否则提供*msg*的错误信息  
如上断言也有带`debug_`前缀的变体，仅在调试模式下生效，优化模式编译时会被忽略。  

### 一些测试注释
某些情况下需要用`#[should_panic]`属性测试错误的结果，也就是预期的断言失败的场景：  
某些测试也许很沉重，最好单独运行，可以添加`#[ignore]`属性在一般测试中忽略他们。  
需要单独运行这些被忽略的测试时，添加`--ignored`参数给编译后的测试文件运行即可：  
即`./compiled_test_file_name --ignored`  

除了直接运行测试文件，也可以用`cargo test`运行标记了`#[ignore]`属性的测试代码块：  
`cargo test -- --ignored`或`cargo test test_name -- --ignored`  
其中`--`是cargo命令自身的参数结束标记，之后的参数会传递给cargo调用的二进制文件。  

类似的，如果测试代码中有`println!`语句默认会被忽略，是为让测试结果显示得更整洁。  
添加`--nocapture`参数可以让测试代码中的`println!`语句得以执行，用如下命令：  
`cargo test -- --nocapture`或`cargo test test_name -- --nocapture`  

### 默认的特征
断言中可能用到一些默认的特征，例如`assert!(a==b)`中的`==`依赖于*eq()*方法。  
转化后的表达式为`a.eq(&b)`，而该方法依赖于大部分内置实现了的*PartialEq*特征。  
对于用户自定义类型，可以添加`#[derive(Eq,PartialEq)]`以实现类似特征方法。  

### 条件编译
使用`#[cfg(...)]`实现条件编译，仅在指定模式下编译相关的代码，例如`test`模式。  
由此可以将测试代码封装在模块中，仅在运行`cargo test`时测试用代码块才会被编译。  
添加`#[cfg(test)]`属性给`mod tests`确保封装的代码仅用于测试，不会部署生产。  

如上情况下，即便封装的测试代码不带`#[test]`属性也没有关系，依然不会编译到生产。  
但是，每个测试依旧需要带有`#[test]`属性，否则运行`cargo test`时不会得到执行。  

### 运行测试
可以使用`rustc --test filename.rs`或`cargo test`分别在文件和项目级别运行测试。  
也可以使用`cargo test some_test_func`来直接运行指定名称的测试。  


### 文档类型
可以将代码示例嵌入文档，并在单元测试时运行文档示例，同时达到解释代码和测试目的。  
代码中的文档可以采用元素级或模块级注释，分别对模块中个别元素或整个模块做注释。  

元素级注释在结构体、枚举声明、函数或特征常量上方，用`///`或`/**/`在单行或多行。  
模块级注释在main.rs或lib.rs或任意模块的根层级，用`//!`或`/*!`和`*/`在当行或多行。  
文档注释支持*markdown*语法，也支持```let a=23;```这样的可执行Rust测试用代码。  

### 生成文档
命令`cargo doc`会在`target/doc`中生成文档，参数`--no--deps`跳过为依赖项建档。 
参数`--open`会在创建文档后用本地浏览器打开文档的HTML页面，托管方式有如下三个：  
* 托管在`crates.io`上的程序会自动生成说明文档并托管在`docs.rs`上。
* GitHub上的程序，其文档自然也会托管在GitHub上，一并上传和更新。
* 专用Web服务器可以托管内容更多结构复杂的文档，如Rust标准库文档。
要创建结构化的本地文档，可以使用基于Markdown语法的[mdbook](https://rust-lang.github.io/mdBook/)命令行工具。  
另外，模块级文档内容会出现在使用如上方式生成的最终文档中，而元素级的文档不会。  

### 文档属性
文档属性用于调整生成的文档页面，使用`#[doc(key=value)]`的语法格式，举例如下：  
* #![doc(html_logo_url="http://pngimg.com/uploads/peace_symbol/peace_symbol_PNG56.png")]设置文档页徽标
* #![doc(html_root_url="https://docs.rs/slotmap/0.2.1")]设置文档的根URL
* #![doc(html_playground_url="https://play.rust-lang.org/")]为文档中的Rust代码提供运行按钮
* #[doc(hidden)]对已经编写注释的内容做隐藏，不发布到生成的文档中
* #[doc(include)]用于引用来自其他文件的文档

### 基准测试
运行`cargo bench`命令可以分析代码中各部分的执行效率，是基准测试的基础工具。  
Rust内置的基准测试框架通过多次迭代计算操作平均时间并评估代码性能，借助：
* 被测试函数需带有`#[bench]`注释，表示该函数是一个基准测试。
* 使用内部编译器软件包*libtest*的*Bencher*类，执行多次迭代操作。

基准测试文件头部需要以`#![feature(test)]`开始，而该功能也需要夜间版编译器。  
首先运行`rustup update nightly`确保安装了夜间版编译器，接着到基准测试目录：  
运行`rustup override set nightly`覆盖默认工具链后执行`cargo bench`命令。  
Rust内置基准测试用纳秒计算的每次迭代的平均时间，并用`(+/- n)`表示偏差值。  

社区提供的`criterion-rs`提供基于标准版编译器的基准测试，以及更详细易懂的报告。  
具体可以查看关于[criterion](https://docs.rs/criterion/latest/criterion/)和[cargo-criterion](https://lib.rs/crates/cargo-criterion)的相关文档

### 自动化集成
为了对每次代码更改实现自动单元和集成测试，可以应用基于事件钩子的持续集成服务。  
Travis就是提供类似服务的一个网站，支持对GitHub上的项目更新进行自动集成测试。  
