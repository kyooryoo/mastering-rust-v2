## 概念
程序和内存，堆栈和堆，所有权、借用和生命周期，指针。  
进程、内存分配、内存管理、内存安全、智能指针类型。  
使用特征来管理驻留内存中的类型，以及如何释放他们。  

## 程序和内存
程序运行在进程上，或者说进程就是程序的运行实例。  
进程需要内存来存储自己的指令，运行时也需要资源空间。  
跟踪函数调用，局部变量和最后一次调用函数返回的地址。  


从低位地址到高位地址，进程的内存布局如下：  
* 堆栈 保存局部变量和函数的返回地址  
+ 预知大小的所有资源和程序创建的中间或临时变量  
* 堆片段 存储大小未知的动态分配的数据  
+ 运行时数据值可能更改，寿命可能比生声明函数更长  
* 未初始化数据 保存程序中声明的所有全局和静态值  
+ 也叫做以符号开始的块，加载到内存时会被初始化为零  
* 已初始化数据  
* 文本段 保存已编译的二进制文件中执行的实际代码  

为了安全性和隔离故障，程序不可以直接访问物理内存。  
操作系统使用页面文件维护从映射虚拟到物理内存的映射。  
内存管理单元负责从虚拟内存到物理内存的实际转换。
为保证性能，内存以块为单位被请求和处理，称为内存分配。  

## 内存管理
早期的语言手动管理内存的请求和释放，或使用守护线程。  
CPP和Rust通过类型系统抽象，如智能指针，来减轻负担。  
现代编程语言的内存策略大致可分为以下三类：  
* 手动型 即完全由程序员负责，使用完后调用函数释放。  
+ C语言，程序使用完内存后需要用free函数来释放内存  
* 自动型 依赖额外的运行时守护线程，与程序一同运行。
+ 如Python和Java等基于虚拟机的动态语言，守护线程  
* 半自动 没有专用的守护线程，但提供引用计数类型。
+ Swift等提供引用计数类型，细颗粒度的实现自动管理    

## 内存分配
堆栈保存编译时已知大小的短期值，在函数返回后清理。  
相对的，堆通过智能指针显式保存超出函数调用范围的值。  
Rust倾向于使用堆栈来分配内存，使用堆需要显式声明。  

